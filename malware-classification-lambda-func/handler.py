try:
    import unzip_requirements
except Exception as e:
    print(f'Exception occured while importing unzip_req: {str(e)}')

try:
    import os
    import json
    import sys

    import torch
    import torchvision
    import PIL 

    import numpy as np
    from PIL import Image

    import json,boto3,io,os,base64,sys

    print('torch version:',torch.__version__)
    print('torchvision version:',torchvision.__version__)
    print('Pillow version:',PIL.__version__)
except Exception as e:
    print(f'Exception occured while importing : {str(e)}')


# define env variables if there are not existing
S3_BUCKET   = os.environ['MODEL_BUCKET_NAME'] if 'MODEL_BUCKET_NAME' in os.environ else 'vamsi-projects'
MODEL_PATH  = os.environ['MODEL_FILE_NAME_KEY'] if 'MODEL_FILE_NAME_KEY' in os.environ else '1_malware-classifiction/model/model_99_98_97_acc.pth'
print('### S3 Bkt is : {} and Model path is : {}'.format(S3_BUCKET,MODEL_PATH))


# Create client to AWS S3
s3 = boto3.client('s3') 


def malware_classify(event, context):
    print(f'Event is : {event}')
    device='cpu'
    num_classes = 25
    output_db = {'Adialer.C': 0,
                'Agent.FYI': 1,
                'Allaple.A': 2,
                'Allaple.L': 3,
                'Alueron.gen!J': 4,
                'Autorun.K': 5,
                'C2LOP.P': 6,
                'C2LOP.gen!g': 7,
                'Dialplatform.B': 8,
                'Dontovo.A': 9,
                'Fakerean': 10,
                'Instantaccess': 11,
                'Lolyda.AA1': 12,
                'Lolyda.AA2': 13,
                'Lolyda.AA3': 14,
                'Lolyda.AT': 15,
                'Malex.gen!J': 16,
                'Obfuscator.AD': 17,
                'Rbot!gen': 18,
                'Skintrim.N': 19,
                'Swizzor.gen!E': 20,
                'Swizzor.gen!I': 21,
                'VB.AT': 22,
                'Wintrim.BX': 23,
                'Yuner.A': 24
            }

    try:
        # 1. Decode Image based on content-type
        print(event)
        content_type_header = event['headers']['content-type']
        print(f'Found content type header : {content_type_header}')
        # print(event['headers'])

        if isinstance(event, str):
            event = json.loads(event)
        # Check if the response body is Base64-encoded
        if event['isBase64Encoded']:
            # Decode the Base64-encoded image data
            image_data = base64.b64decode(event['body'])
        else:
            image_data = event['body']

        # Convert the image data to a NumPy array
        np_array = np.array(Image.open(io.BytesIO(image_data)))
        print(np_array.shape)
        gray_img = np_array

        # Convert the grayscale image to RGB
        rgb_img = np.repeat(gray_img[:, :, np.newaxis], 3, axis=-1)
        print(gray_img.shape,rgb_img.shape)
        print('### Converted to RGB')

        # Model load:
        # Create an instance of the ResNet34 model
        model = torchvision.models.resnet34()

        # Freeze the weights of the pre-trained layers
        for param in model.parameters():
            param.requires_grad = False

        # Replace the classifier with a new one for transfer learning
        num_ftrs = model.fc.in_features
        model.fc = torch.nn.Linear(num_ftrs, num_classes) # change the output size to 25

        # Move the model to the specified device (CPU or GPU)
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        model = model.to(device)
        print(model.fc)
    
        print('### Model loaded')


        try:
            obj         = s3.get_object(Bucket = S3_BUCKET, Key = MODEL_PATH)
            bytestream  = io.BytesIO(obj['Body'].read())
            print('### Loading model.pth file from s3...')
            print(f'### Model Size: {sys.getsizeof(bytestream) // (1024 * 1024)} MB')
            
            model.load_state_dict(torch.load(bytestream,map_location=torch.device('cpu')))
            model.eval()
        except Exception as e:
            print('### Exception in loading a model : {}'.format(str(e)))
            raise(e)


        # Prediction:
        print('### Predicting the uploaded image')
        # convert the NumPy array into a PIL image
        img = Image.fromarray(rgb_img)
        
        # create a PyTorch tensor from the NumPy array
        # img_tensor = torch.from_numpy(rgb_img)

        # Apply tranformations:    
        re_size = (256,256)

        transform = torchvision.transforms.Compose([
            torchvision.transforms.Resize(re_size),
            torchvision.transforms.ToTensor(),
            torchvision.transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])

        img_t = transform(img)
        print('### Image transformed')

        with torch.no_grad():
            pred_img = model(img_t.unsqueeze(0)).detach().cpu()
            pred_img = pred_img[0]
            predicted_malware_class = list(output_db.keys())[list(output_db.values()).index(pred_img.argmax())]
            print(f'### Image predicted as : {predicted_malware_class}')


        return {
            "statusCode": 200,
            "headers": {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                "Access-Control-Allow-Credentials": True
            },
            "body": json.dumps({ 'predicted': predicted_malware_class})
        }
    except Exception as e:
        print(repr(e))
        return {
            "statusCode": 500,
            "headers": {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                "Access-Control-Allow-Credentials": True
            },
            "body": json.dumps({"error": repr(e)})
        }